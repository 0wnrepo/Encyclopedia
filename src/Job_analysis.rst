
================================================================================
Job Analysis
================================================================================

Job analysis is...

Job analysis has two parts: requirements analysis and organizational
architecture.

- Requirements analysis is the process of identifying and categorizing company
  concerns

- Organizational architecture is the process of allocating concerns onto
  organization structure

The process of determining who to hire delivers a *job description*, which
enumerates day-to-day responsibilities and minimum and preferred qualifications.

In general, there are two kinds of jobs: specialist jobs and generalist jobs.

- A specialist job is a job with static qualifications.
- A generalist job is a job with dynamic qualifications.

Most jobs (e.g. barista, cab driver, doctor) are specialist jobs. Generalists jobs exist in volatile industries where productivity depends on the ability of employees to rapidly pick up new skills.

The software industry employs both specialists and generalist. Of note, however, is the relatively high demand of generalist employees whose job descriptions are simply "software engineer" or "software developer".

---

Another popular title is "rockstar", "ninja", "superstar", or "wizard". It's unclear what these employers are looking for exactly.

## Defining Quality

What makes a software engineer good?

To answer that, it is useful to first consider, what makes _any_ worker good?

If we consider companies a proxy for the market, then the quality of a worker is his ability to create value (or wealth), which presumably is a function of the _quality_ and _quantity_ of his labor.

This may be hard to see at first since in most jobs, the quality of labor is fairly consistent. Software however, is scalable, and exhibits wide variations in the quality of workers.

### Smart and Gets Things Done

A popular heuristic invented by Microsoft evaluates developers based the extent to which they are "smart and get things done".[1],[2]

Joel Spolsky, CEO of Fog Creek and ex-Microsoft manager, further adds the condition "Not a jerk."[4]

Paul Graham, further corroborates:[3]

> For programmers we had three additional tests. Was the person genuinely smart? If so, could they actually get things done? And finally, since a few good hackers have unbearable personalities, could we stand to have them around?

Graham notes however the "not a jerk" is usually not necessary, since truly smart people usually express Socratic humility rather than unbearable attitude. He notes, however, that the test can be invalidated by the environment, where even truly smart people can be manipulated to be 'know-it-all's.

Graham further extends the hiring criteria by adding an "animal test":

> One of the best tricks I learned during our startup was a rule for deciding who to hire. Could you describe the person as an animal? ... It means someone who takes their work a little too seriously; someone who does what they do so well that they pass right through professional and cross over into obsessive.

Loosely interpreted, Graham is describing (irrational) passion, which Spolsky
explicitly considers an indicator of intelligence rather than a desirable
criteria in-itself.

---

As a matter of simplicity and generalizability, we will assume here that good
candidates are "smart and get things done". More precisely, when we say a person
is "smart and gets things done" we mean that a person has properties:

- Intelligent: The candidate solves problems the right way

- Productive: The candidate solves the right problems

Why intelligent and productive?

- Candidates that lack productivity, naturally, do not produce much work or fail
  to prioritize tasks correctly.

- Candidates that lack intelligence produce poor work which slows other
  developers down.


Notably, when hiring generalists, measures of quality should not be influenced by the presence of experience with particular skills.

.. [1] http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html

.. [2] . "How Would You Move Mount Fuji? - Wiliam Poundstone, 2003"

.. [3] http://www.paulgraham.com/start.html
.. [4] http://www.joelonsoftware.com/articles/FieldGuidetoDevelopers.html
